

A prompt for generating a web page with a translator for the Oflameron text programming language.
The language is primarily developed as a prompt, which can be used to generate a translator in AI.
The Oflameron language is focused more on text obfuscation than cryptography.

Oflameron Program Language ver 1.40 © by Valery Shmelev 02.2026  https://oflameron.com


Request to Deepseek:

Here's the most detailed and refined request, incorporating all our discussions. It includes explicit comments, function and variable descriptions, and all the clarified aspects of the interpreter. Now everything is ready to generate perfect code.

Request to Deepseek:

Request prototype version 1.40 (with character rotation)

Write HTML and JavaScript code for a web page optimized for viewing on a smartphone with vertical orientation.
Web page encoding: win-1251.

Interface elements:

Page title (h1): "Oflameron language interpreter ver 1.40 (with rotation)".

Field #1 (textarea): id="keyInput", placeholder="Prime number (key for XOR)". Initial value: giant number (see below). Label: "Enter the key as a string of digits".

Field #2 (textarea): id="sourceCode", placeholder="Oflameron program source code". Contains all user-entered code, including unprocessed characters. Changes to this field should automatically update Field #3 (cleaned code).

Field #3 (textarea): id="cleanCode", placeholder="Oflameron program code (clear)", readonly. Program code cleared of characters not included in the list a, b, c, d, e, p, t, v, w, h, q, l, k, f, g, i, m, n. Updated in real time when Field #2 changes. Important: During program execution (RUN), the nq operator can change the contents of this field (self-modification of the code), and these changes must be immediately visible.

Field #4 (textarea, readonly): id="resultText", placeholder="Result / Ciphertext". Contains the text generated by the mX operator (character output).

Field #5 (textarea, readonly): id="resultNumeric", placeholder="Result / Ciphertext (decimal codes)". Contains the same result as field #4, but as a continuous string of decimal ASCII codes for each character (e.g., "Hello" -> "72101108108111"). Updated simultaneously with field #4.

Buttons:

id="runButton" — RUN. Runs the interpreter.

id="xorButton" — XOR. Performs an XOR operation between the text from field #1 (the key as a numeric string) and the text from field #4. The result is placed in field #4 (and, accordingly, in field #5).

id="showRotationButton" — "Show Rotation Table." Displays the current mapping of symbols to their functions in the message block.

Message block (div): id="messageDiv". Used to display the rotation table, error messages, and completion information (e.g., "Done in N steps").

Rotation information block (p or div): "STP (rotation step by list a, b, c, d, e, p, t, v, w, h, q, l, k, f, g, i, m, n) = 1 (change in web page JavaScript)".

Initial key value (for Field #1):

text
176684706477838432958329750074291851582748389687561895812160620129261977163358586401104946332014022802424840484736440263640058869150064213123847594034139965365510006253457917812163931669483321

Oflameron Interpreter Specification with Rotation:

1. Constants and Parameters:

javascript
// Rotation step. To change this, edit this code.
const STP = 1;

// Initial order of the 18 language symbols.
const SYMBOL_ORDER = ['a','b','c','d','e','p','t','v','w','h','q','l','k','f','g','i','m','n'];
// Indices:
// 0-8: constants (a, b, c, d, e, p, t, v, w)
// 9-12: variables (h, q, l, k)
// 13-17: operators (f, g, i, m, n)
2. Initial values ??of interpreter variables:

javascript
let h = 0; // Accumulator (result of f, g, i operations), data source for nq.
let q = 0; // Variable (often used as an index into nq).
let l = 0; // Variable (stores the ASCII code read by the lX operator).
let k = 0; // Pointer (index) of the current position in the cleared line of code (Field #3). Only incremented. Not used as an operand in calculations.
3. Initial numeric values ??of constants (before rotation):

javascript
const INITIAL_CONSTANT_VALUES = {
    'a': 0, 'b': 1, 'c': 3, 'd': 5, 'e': 7,
    'p': 19, 't': 23, 'v': 43, 'w': 73
};
// Variables h, q, l, k initial value = 0.
// Symbols f, g, i, m, n do not have numeric values; they are operators.
4. Symbol Type System and Mapping:
Each symbol from SYMBOL_ORDER has a description object at any given time, stored in symbolMapping. The object contains:

type: 'constant', 'variable', or 'operator'.

value: numeric value (for constants and variables).

arity: number of operands (for operators: 2 for f, g, i; 1 for l, m; special case for nq).

action: function that performs the operation (for operators).

The createInitialMapping() function creates an initial mapping, where:

a..w — type: 'constant', value from INITIAL_CONSTANT_VALUES.

h, q, l, k — type: 'variable', value: 0.

f — type: 'operator', arity: 2, action: 'multiply' (multiplication).

g — type: 'operator', arity: 2, action: 'add' (addition).

i — type: 'operator', arity: 2, action: 'subtract' (subtraction).

m — type: 'operator', arity: 1, action: 'print' (output).

n — type: 'operator', arity: 'special', action: 'replace' (replacement, works in tandem with q).

l — type: 'operator', arity: 1, action: 'read' (ASCII reading).

5. Rotation function rotateSymbols():
Called after each operator (f,g,i,l,m,nq) has been fully executed. Cyclically shifts the functions of all symbols to the right by STP positions in the SYMBOL_ORDER list. This means that each symbol takes the description object (type, value, action) of the symbol that was STP positions to the left in SYMBOL_ORDER.

javascript
function rotateSymbols() {
const newMapping = {};
for (let i = 0; i < SYMBOL_ORDER.length; i++) {
const currentSymbol = SYMBOL_ORDER[i];
// Index of the symbol whose function we are taking for currentSymbol.
const sourceIndex = (i - STP + SYMBOL_ORDER.length) % SYMBOL_ORDER.length;
const sourceSymbol = SYMBOL_ORDER[sourceIndex];
newMapping[currentSymbol] = symbolMapping[sourceSymbol];
}
symbolMapping = newMapping;
}
Important: After rotation, a symbol inherits its type, value, and action. For example, if after rotation, a inherits the function from b, then symbolMapping['a'] becomes {type:'constant', value:1, ...}.

6. Normalization function normalize(num):
Applies to the result of each mathematical operation (in f, g, i) and to the operands X in lX, mX, nq.

javascript
function normalize(num) {
// Cast to an integer.
num = Math.floor(num);
// Convert to the range 0..127 by cyclically subtracting 127.
while (num > 127) num -= 127;
// Absolute value, if negative.
if (num < 0) num = Math.abs(num);
return num;
}

7. Execution Rules:

Execution is strictly left-to-right on the cleared line of code (Field #3).

k is the current position indicator. It only increments.

Error/Unknown Symbol: If the symbol at position k is not in SYMBOL_ORDER (this should not be the case in the cleared line) or its current type does not allow the expected operation (for example, the operator did not receive enough operands), the interpreter simply evaluates k = k + 1 and moves to the next symbol.

Loop Protection: Maximum 100,000 steps (one increment of k = one step). When the limit is reached, execution is interrupted, a warning is displayed in the message block, and the result generated so far remains in fields #4 and #5.

8. Operators (in their ORIGINAL state, before rotation):

fXY (3 symbols): Multiplication.

X, Y are the operands. Must be symbols whose current type is 'constant' or 'variable' (i.e., have a numeric value).

Calculation: h = normalize( getValue(X) * getValue(Y) ).

After execution: k = k + 3, then rotateSymbols().

gXY (3 symbols): Addition.

X, Y — as above.

Calculation: h = normalize( getValue(X) + getValue(Y) ).

After execution: k = k + 3, then rotateSymbols().

iXY (3 symbols): Subtraction.

X, Y — as above.

Calculation: h = normalize( Math.abs( getValue(X) - getValue(Y) ) ).

After execution: k = k + 3, then rotateSymbols().

lX (2 characters): Read the ASCII code of a character from the program code.

X is the operand (constant or variable).

Calculation: targetIndex = k + normalize( getValue(X) ).

If targetIndex is within the code string (Field #3), then take the char character from that position and write l = char.charCodeAt(0). Otherwise, l = 0.

After execution: k = k + 2, then rotateSymbols().

mX (2 characters): Print the character.

X is the operand (constant or variable).

Calculation: charCode = normalize( getValue(X) ).

Action: char = String.fromCharCode(charCode). This character is appended to the end of the string in field #4 (resultText). Simultaneously, the decimal code charCode is appended (as a string) to the end of field #5 (resultNumeric).

After execution: k = k + 2, then rotateSymbols().

nq (2 characters): Replace a character in program code (self-modification).

Important: This is a single operator consisting of the characters n and q. The interpreter searches for this sequence.

Uses the current values ??of the variables q and h.

Calculation: targetIndex = k + normalize( q ).

If targetIndex is within the code string (Field #3), then replace the character at this position with String.fromCharCode( normalize( h ) ).

Critical: This replacement immediately modifies the string in Field #3 (cleanCode) and, more importantly, the internal string on which the interpreter continues to work. Therefore, subsequent statements can read the already modified code.

After execution: k = k + 2, then rotateSymbols().

9. Helper function getValue(symbolChar):
Returns the current numeric value of a symbol. Works only for symbols with the type 'constant' or 'variable'. For operators, returns NaN or raises an error (such a symbol should not be supplied as an operand).

javascript
function getValue(symbolChar) {
const obj = symbolMapping[symbolChar];
if (obj && (obj.type === 'constant' || obj.type === 'variable')) {
return obj.value;
}
return NaN; // Invalid operand.
}
10. Button logic:

RUN:

Reset variables: h = q = l = k = 0.
Reset symbolMapping to its initial state (call createInitialMapping()).
Completely clear fields #4 (resultText) and #5 (resultNumeric).
Restore the contents of field #3 (cleanCode) by clearing the current contents of field #2 (sourceCode) of all characters except the permitted ones (SYMBOL_ORDER). This ensures that each RUN starts with the source code.
Begin interpretation with k = 0 on the updated line of field #3.
Upon completion (end of code or 100,000 steps reached), output a message to messageDiv (e.g., "Done in N steps").

XOR:
Take the key keyStr = the value of field #1 (keyInput) as a string.
Take the text textStr = the value of field #4 (resultText) as a string.
Determine N = Math.min(keyStr.length, textStr.length).
For i = 0 to N-1, calculate: resultCharCode = keyStr.charCodeAt(i) ^ textStr.charCodeAt(i).
Generate a result string from characters: String.fromCharCode(resultCharCode).
Replace the contents of field #4 with this result string.
Update field #5: generate a string of decimal codes for the result characters.
"Show rotation table":

Clear messageDiv.
For each symbol sym in SYMBOL_ORDER, get its current object obj = symbolMapping[sym].
Generate a description string:
If obj.type === 'constant': "a > b (constant, value 1)".
If obj.type === 'variable': "h > q (variable, value 0)".
If obj.type === 'operator': "f > g (operator, addition, arity=2)".
Output all strings in a messageDiv (for example, separated by <br> or in <pre>).
11. Responsive design:

Use <meta name="viewport" content="width=device-width, initial-scale=1.0">.

All textareas should have width: 100%, box-sizing: border-box.

Buttons should be large and easy to touch.

Fonts should be readable on mobile devices.

12. Encoding and text processing:

Specify the encoding <meta charset="windows-1251">.

Perform all character manipulation using standard JavaScript methods (.charCodeAt(), String.fromCharCode()), which work with Unicode (UTF-16). This is acceptable, as the Oflameron language only handles ASCII-compatible characters and codes 0-127.

Now the request contains all the specified details and is ready for implementation.

https://chat.deepseek.com/share/5uv6th7lkivqkx5mv6

https://t.me/llmsource/429






